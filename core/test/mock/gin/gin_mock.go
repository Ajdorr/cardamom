// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package gin_mock

import (
	"bufio"
	"net"
	"net/http"

	"github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// NewMockResponseWriter creates a new instance of MockResponseWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockResponseWriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockResponseWriter {
	mock := &MockResponseWriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockResponseWriter is an autogenerated mock type for the ResponseWriter type
type MockResponseWriter struct {
	mock.Mock
}

type MockResponseWriter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockResponseWriter) EXPECT() *MockResponseWriter_Expecter {
	return &MockResponseWriter_Expecter{mock: &_m.Mock}
}

// CloseNotify provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) CloseNotify() <-chan bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for CloseNotify")
	}

	var r0 <-chan bool
	if returnFunc, ok := ret.Get(0).(func() <-chan bool); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan bool)
		}
	}
	return r0
}

// MockResponseWriter_CloseNotify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CloseNotify'
type MockResponseWriter_CloseNotify_Call struct {
	*mock.Call
}

// CloseNotify is a helper method to define mock.On call
func (_e *MockResponseWriter_Expecter) CloseNotify() *MockResponseWriter_CloseNotify_Call {
	return &MockResponseWriter_CloseNotify_Call{Call: _e.mock.On("CloseNotify")}
}

func (_c *MockResponseWriter_CloseNotify_Call) Run(run func()) *MockResponseWriter_CloseNotify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockResponseWriter_CloseNotify_Call) Return(boolCh <-chan bool) *MockResponseWriter_CloseNotify_Call {
	_c.Call.Return(boolCh)
	return _c
}

func (_c *MockResponseWriter_CloseNotify_Call) RunAndReturn(run func() <-chan bool) *MockResponseWriter_CloseNotify_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) Flush() {
	_mock.Called()
	return
}

// MockResponseWriter_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type MockResponseWriter_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *MockResponseWriter_Expecter) Flush() *MockResponseWriter_Flush_Call {
	return &MockResponseWriter_Flush_Call{Call: _e.mock.On("Flush")}
}

func (_c *MockResponseWriter_Flush_Call) Run(run func()) *MockResponseWriter_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockResponseWriter_Flush_Call) Return() *MockResponseWriter_Flush_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockResponseWriter_Flush_Call) RunAndReturn(run func()) *MockResponseWriter_Flush_Call {
	_c.Run(run)
	return _c
}

// Header provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) Header() http.Header {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Header")
	}

	var r0 http.Header
	if returnFunc, ok := ret.Get(0).(func() http.Header); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Header)
		}
	}
	return r0
}

// MockResponseWriter_Header_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Header'
type MockResponseWriter_Header_Call struct {
	*mock.Call
}

// Header is a helper method to define mock.On call
func (_e *MockResponseWriter_Expecter) Header() *MockResponseWriter_Header_Call {
	return &MockResponseWriter_Header_Call{Call: _e.mock.On("Header")}
}

func (_c *MockResponseWriter_Header_Call) Run(run func()) *MockResponseWriter_Header_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockResponseWriter_Header_Call) Return(header http.Header) *MockResponseWriter_Header_Call {
	_c.Call.Return(header)
	return _c
}

func (_c *MockResponseWriter_Header_Call) RunAndReturn(run func() http.Header) *MockResponseWriter_Header_Call {
	_c.Call.Return(run)
	return _c
}

// Hijack provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Hijack")
	}

	var r0 net.Conn
	var r1 *bufio.ReadWriter
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (net.Conn, *bufio.ReadWriter, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() net.Conn); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(net.Conn)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() *bufio.ReadWriter); ok {
		r1 = returnFunc()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*bufio.ReadWriter)
		}
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockResponseWriter_Hijack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Hijack'
type MockResponseWriter_Hijack_Call struct {
	*mock.Call
}

// Hijack is a helper method to define mock.On call
func (_e *MockResponseWriter_Expecter) Hijack() *MockResponseWriter_Hijack_Call {
	return &MockResponseWriter_Hijack_Call{Call: _e.mock.On("Hijack")}
}

func (_c *MockResponseWriter_Hijack_Call) Run(run func()) *MockResponseWriter_Hijack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockResponseWriter_Hijack_Call) Return(conn net.Conn, readWriter *bufio.ReadWriter, err error) *MockResponseWriter_Hijack_Call {
	_c.Call.Return(conn, readWriter, err)
	return _c
}

func (_c *MockResponseWriter_Hijack_Call) RunAndReturn(run func() (net.Conn, *bufio.ReadWriter, error)) *MockResponseWriter_Hijack_Call {
	_c.Call.Return(run)
	return _c
}

// Pusher provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) Pusher() http.Pusher {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Pusher")
	}

	var r0 http.Pusher
	if returnFunc, ok := ret.Get(0).(func() http.Pusher); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Pusher)
		}
	}
	return r0
}

// MockResponseWriter_Pusher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pusher'
type MockResponseWriter_Pusher_Call struct {
	*mock.Call
}

// Pusher is a helper method to define mock.On call
func (_e *MockResponseWriter_Expecter) Pusher() *MockResponseWriter_Pusher_Call {
	return &MockResponseWriter_Pusher_Call{Call: _e.mock.On("Pusher")}
}

func (_c *MockResponseWriter_Pusher_Call) Run(run func()) *MockResponseWriter_Pusher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockResponseWriter_Pusher_Call) Return(pusher http.Pusher) *MockResponseWriter_Pusher_Call {
	_c.Call.Return(pusher)
	return _c
}

func (_c *MockResponseWriter_Pusher_Call) RunAndReturn(run func() http.Pusher) *MockResponseWriter_Pusher_Call {
	_c.Call.Return(run)
	return _c
}

// Size provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) Size() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Size")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockResponseWriter_Size_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Size'
type MockResponseWriter_Size_Call struct {
	*mock.Call
}

// Size is a helper method to define mock.On call
func (_e *MockResponseWriter_Expecter) Size() *MockResponseWriter_Size_Call {
	return &MockResponseWriter_Size_Call{Call: _e.mock.On("Size")}
}

func (_c *MockResponseWriter_Size_Call) Run(run func()) *MockResponseWriter_Size_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockResponseWriter_Size_Call) Return(n int) *MockResponseWriter_Size_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockResponseWriter_Size_Call) RunAndReturn(run func() int) *MockResponseWriter_Size_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) Status() int {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 int
	if returnFunc, ok := ret.Get(0).(func() int); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int)
	}
	return r0
}

// MockResponseWriter_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockResponseWriter_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
func (_e *MockResponseWriter_Expecter) Status() *MockResponseWriter_Status_Call {
	return &MockResponseWriter_Status_Call{Call: _e.mock.On("Status")}
}

func (_c *MockResponseWriter_Status_Call) Run(run func()) *MockResponseWriter_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockResponseWriter_Status_Call) Return(n int) *MockResponseWriter_Status_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockResponseWriter_Status_Call) RunAndReturn(run func() int) *MockResponseWriter_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) Write(bytes []byte) (int, error) {
	ret := _mock.Called(bytes)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(bytes)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(bytes)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(bytes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockResponseWriter_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockResponseWriter_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - bytes []byte
func (_e *MockResponseWriter_Expecter) Write(bytes interface{}) *MockResponseWriter_Write_Call {
	return &MockResponseWriter_Write_Call{Call: _e.mock.On("Write", bytes)}
}

func (_c *MockResponseWriter_Write_Call) Run(run func(bytes []byte)) *MockResponseWriter_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []byte
		if args[0] != nil {
			arg0 = args[0].([]byte)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockResponseWriter_Write_Call) Return(n int, err error) *MockResponseWriter_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockResponseWriter_Write_Call) RunAndReturn(run func(bytes []byte) (int, error)) *MockResponseWriter_Write_Call {
	_c.Call.Return(run)
	return _c
}

// WriteHeader provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) WriteHeader(statusCode int) {
	_mock.Called(statusCode)
	return
}

// MockResponseWriter_WriteHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteHeader'
type MockResponseWriter_WriteHeader_Call struct {
	*mock.Call
}

// WriteHeader is a helper method to define mock.On call
//   - statusCode int
func (_e *MockResponseWriter_Expecter) WriteHeader(statusCode interface{}) *MockResponseWriter_WriteHeader_Call {
	return &MockResponseWriter_WriteHeader_Call{Call: _e.mock.On("WriteHeader", statusCode)}
}

func (_c *MockResponseWriter_WriteHeader_Call) Run(run func(statusCode int)) *MockResponseWriter_WriteHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockResponseWriter_WriteHeader_Call) Return() *MockResponseWriter_WriteHeader_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockResponseWriter_WriteHeader_Call) RunAndReturn(run func(statusCode int)) *MockResponseWriter_WriteHeader_Call {
	_c.Run(run)
	return _c
}

// WriteHeaderNow provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) WriteHeaderNow() {
	_mock.Called()
	return
}

// MockResponseWriter_WriteHeaderNow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteHeaderNow'
type MockResponseWriter_WriteHeaderNow_Call struct {
	*mock.Call
}

// WriteHeaderNow is a helper method to define mock.On call
func (_e *MockResponseWriter_Expecter) WriteHeaderNow() *MockResponseWriter_WriteHeaderNow_Call {
	return &MockResponseWriter_WriteHeaderNow_Call{Call: _e.mock.On("WriteHeaderNow")}
}

func (_c *MockResponseWriter_WriteHeaderNow_Call) Run(run func()) *MockResponseWriter_WriteHeaderNow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockResponseWriter_WriteHeaderNow_Call) Return() *MockResponseWriter_WriteHeaderNow_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockResponseWriter_WriteHeaderNow_Call) RunAndReturn(run func()) *MockResponseWriter_WriteHeaderNow_Call {
	_c.Run(run)
	return _c
}

// WriteString provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) WriteString(s string) (int, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for WriteString")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (int, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) int); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockResponseWriter_WriteString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteString'
type MockResponseWriter_WriteString_Call struct {
	*mock.Call
}

// WriteString is a helper method to define mock.On call
//   - s string
func (_e *MockResponseWriter_Expecter) WriteString(s interface{}) *MockResponseWriter_WriteString_Call {
	return &MockResponseWriter_WriteString_Call{Call: _e.mock.On("WriteString", s)}
}

func (_c *MockResponseWriter_WriteString_Call) Run(run func(s string)) *MockResponseWriter_WriteString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockResponseWriter_WriteString_Call) Return(n int, err error) *MockResponseWriter_WriteString_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockResponseWriter_WriteString_Call) RunAndReturn(run func(s string) (int, error)) *MockResponseWriter_WriteString_Call {
	_c.Call.Return(run)
	return _c
}

// Written provides a mock function for the type MockResponseWriter
func (_mock *MockResponseWriter) Written() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Written")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockResponseWriter_Written_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Written'
type MockResponseWriter_Written_Call struct {
	*mock.Call
}

// Written is a helper method to define mock.On call
func (_e *MockResponseWriter_Expecter) Written() *MockResponseWriter_Written_Call {
	return &MockResponseWriter_Written_Call{Call: _e.mock.On("Written")}
}

func (_c *MockResponseWriter_Written_Call) Run(run func()) *MockResponseWriter_Written_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockResponseWriter_Written_Call) Return(b bool) *MockResponseWriter_Written_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockResponseWriter_Written_Call) RunAndReturn(run func() bool) *MockResponseWriter_Written_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIRouter creates a new instance of MockIRouter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIRouter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIRouter {
	mock := &MockIRouter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIRouter is an autogenerated mock type for the IRouter type
type MockIRouter struct {
	mock.Mock
}

type MockIRouter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIRouter) EXPECT() *MockIRouter_Expecter {
	return &MockIRouter_Expecter{mock: &_m.Mock}
}

// Any provides a mock function for the type MockIRouter
func (_mock *MockIRouter) Any(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Any")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_Any_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Any'
type MockIRouter_Any_Call struct {
	*mock.Call
}

// Any is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) Any(s interface{}, handlerFuncs ...interface{}) *MockIRouter_Any_Call {
	return &MockIRouter_Any_Call{Call: _e.mock.On("Any",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRouter_Any_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_Any_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRouter_Any_Call) Return(iRoutes gin.IRoutes) *MockIRouter_Any_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_Any_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_Any_Call {
	_c.Call.Return(run)
	return _c
}

// DELETE provides a mock function for the type MockIRouter
func (_mock *MockIRouter) DELETE(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DELETE")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_DELETE_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DELETE'
type MockIRouter_DELETE_Call struct {
	*mock.Call
}

// DELETE is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) DELETE(s interface{}, handlerFuncs ...interface{}) *MockIRouter_DELETE_Call {
	return &MockIRouter_DELETE_Call{Call: _e.mock.On("DELETE",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRouter_DELETE_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_DELETE_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRouter_DELETE_Call) Return(iRoutes gin.IRoutes) *MockIRouter_DELETE_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_DELETE_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_DELETE_Call {
	_c.Call.Return(run)
	return _c
}

// GET provides a mock function for the type MockIRouter
func (_mock *MockIRouter) GET(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GET")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_GET_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GET'
type MockIRouter_GET_Call struct {
	*mock.Call
}

// GET is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) GET(s interface{}, handlerFuncs ...interface{}) *MockIRouter_GET_Call {
	return &MockIRouter_GET_Call{Call: _e.mock.On("GET",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRouter_GET_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_GET_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRouter_GET_Call) Return(iRoutes gin.IRoutes) *MockIRouter_GET_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_GET_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_GET_Call {
	_c.Call.Return(run)
	return _c
}

// Group provides a mock function for the type MockIRouter
func (_mock *MockIRouter) Group(s string, handlerFuncs ...gin.HandlerFunc) *gin.RouterGroup {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Group")
	}

	var r0 *gin.RouterGroup
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) *gin.RouterGroup); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gin.RouterGroup)
		}
	}
	return r0
}

// MockIRouter_Group_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Group'
type MockIRouter_Group_Call struct {
	*mock.Call
}

// Group is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) Group(s interface{}, handlerFuncs ...interface{}) *MockIRouter_Group_Call {
	return &MockIRouter_Group_Call{Call: _e.mock.On("Group",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRouter_Group_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_Group_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRouter_Group_Call) Return(routerGroup *gin.RouterGroup) *MockIRouter_Group_Call {
	_c.Call.Return(routerGroup)
	return _c
}

func (_c *MockIRouter_Group_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) *gin.RouterGroup) *MockIRouter_Group_Call {
	_c.Call.Return(run)
	return _c
}

// HEAD provides a mock function for the type MockIRouter
func (_mock *MockIRouter) HEAD(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HEAD")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_HEAD_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HEAD'
type MockIRouter_HEAD_Call struct {
	*mock.Call
}

// HEAD is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) HEAD(s interface{}, handlerFuncs ...interface{}) *MockIRouter_HEAD_Call {
	return &MockIRouter_HEAD_Call{Call: _e.mock.On("HEAD",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRouter_HEAD_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_HEAD_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRouter_HEAD_Call) Return(iRoutes gin.IRoutes) *MockIRouter_HEAD_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_HEAD_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_HEAD_Call {
	_c.Call.Return(run)
	return _c
}

// Handle provides a mock function for the type MockIRouter
func (_mock *MockIRouter) Handle(s string, s1 string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, s1, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s, s1)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Handle")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, s1, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockIRouter_Handle_Call struct {
	*mock.Call
}

// Handle is a helper method to define mock.On call
//   - s string
//   - s1 string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) Handle(s interface{}, s1 interface{}, handlerFuncs ...interface{}) *MockIRouter_Handle_Call {
	return &MockIRouter_Handle_Call{Call: _e.mock.On("Handle",
		append([]interface{}{s, s1}, handlerFuncs...)...)}
}

func (_c *MockIRouter_Handle_Call) Run(run func(s string, s1 string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_Handle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 2 {
			variadicArgs = args[2].([]gin.HandlerFunc)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockIRouter_Handle_Call) Return(iRoutes gin.IRoutes) *MockIRouter_Handle_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_Handle_Call) RunAndReturn(run func(s string, s1 string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_Handle_Call {
	_c.Call.Return(run)
	return _c
}

// OPTIONS provides a mock function for the type MockIRouter
func (_mock *MockIRouter) OPTIONS(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for OPTIONS")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_OPTIONS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OPTIONS'
type MockIRouter_OPTIONS_Call struct {
	*mock.Call
}

// OPTIONS is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) OPTIONS(s interface{}, handlerFuncs ...interface{}) *MockIRouter_OPTIONS_Call {
	return &MockIRouter_OPTIONS_Call{Call: _e.mock.On("OPTIONS",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRouter_OPTIONS_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_OPTIONS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRouter_OPTIONS_Call) Return(iRoutes gin.IRoutes) *MockIRouter_OPTIONS_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_OPTIONS_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_OPTIONS_Call {
	_c.Call.Return(run)
	return _c
}

// PATCH provides a mock function for the type MockIRouter
func (_mock *MockIRouter) PATCH(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PATCH")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_PATCH_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PATCH'
type MockIRouter_PATCH_Call struct {
	*mock.Call
}

// PATCH is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) PATCH(s interface{}, handlerFuncs ...interface{}) *MockIRouter_PATCH_Call {
	return &MockIRouter_PATCH_Call{Call: _e.mock.On("PATCH",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRouter_PATCH_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_PATCH_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRouter_PATCH_Call) Return(iRoutes gin.IRoutes) *MockIRouter_PATCH_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_PATCH_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_PATCH_Call {
	_c.Call.Return(run)
	return _c
}

// POST provides a mock function for the type MockIRouter
func (_mock *MockIRouter) POST(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for POST")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_POST_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'POST'
type MockIRouter_POST_Call struct {
	*mock.Call
}

// POST is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) POST(s interface{}, handlerFuncs ...interface{}) *MockIRouter_POST_Call {
	return &MockIRouter_POST_Call{Call: _e.mock.On("POST",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRouter_POST_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_POST_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRouter_POST_Call) Return(iRoutes gin.IRoutes) *MockIRouter_POST_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_POST_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_POST_Call {
	_c.Call.Return(run)
	return _c
}

// PUT provides a mock function for the type MockIRouter
func (_mock *MockIRouter) PUT(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PUT")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_PUT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PUT'
type MockIRouter_PUT_Call struct {
	*mock.Call
}

// PUT is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) PUT(s interface{}, handlerFuncs ...interface{}) *MockIRouter_PUT_Call {
	return &MockIRouter_PUT_Call{Call: _e.mock.On("PUT",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRouter_PUT_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRouter_PUT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRouter_PUT_Call) Return(iRoutes gin.IRoutes) *MockIRouter_PUT_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_PUT_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_PUT_Call {
	_c.Call.Return(run)
	return _c
}

// Static provides a mock function for the type MockIRouter
func (_mock *MockIRouter) Static(s string, s1 string) gin.IRoutes {
	ret := _mock.Called(s, s1)

	if len(ret) == 0 {
		panic("no return value specified for Static")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, string) gin.IRoutes); ok {
		r0 = returnFunc(s, s1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_Static_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Static'
type MockIRouter_Static_Call struct {
	*mock.Call
}

// Static is a helper method to define mock.On call
//   - s string
//   - s1 string
func (_e *MockIRouter_Expecter) Static(s interface{}, s1 interface{}) *MockIRouter_Static_Call {
	return &MockIRouter_Static_Call{Call: _e.mock.On("Static", s, s1)}
}

func (_c *MockIRouter_Static_Call) Run(run func(s string, s1 string)) *MockIRouter_Static_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRouter_Static_Call) Return(iRoutes gin.IRoutes) *MockIRouter_Static_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_Static_Call) RunAndReturn(run func(s string, s1 string) gin.IRoutes) *MockIRouter_Static_Call {
	_c.Call.Return(run)
	return _c
}

// StaticFS provides a mock function for the type MockIRouter
func (_mock *MockIRouter) StaticFS(s string, fileSystem http.FileSystem) gin.IRoutes {
	ret := _mock.Called(s, fileSystem)

	if len(ret) == 0 {
		panic("no return value specified for StaticFS")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, http.FileSystem) gin.IRoutes); ok {
		r0 = returnFunc(s, fileSystem)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_StaticFS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StaticFS'
type MockIRouter_StaticFS_Call struct {
	*mock.Call
}

// StaticFS is a helper method to define mock.On call
//   - s string
//   - fileSystem http.FileSystem
func (_e *MockIRouter_Expecter) StaticFS(s interface{}, fileSystem interface{}) *MockIRouter_StaticFS_Call {
	return &MockIRouter_StaticFS_Call{Call: _e.mock.On("StaticFS", s, fileSystem)}
}

func (_c *MockIRouter_StaticFS_Call) Run(run func(s string, fileSystem http.FileSystem)) *MockIRouter_StaticFS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 http.FileSystem
		if args[1] != nil {
			arg1 = args[1].(http.FileSystem)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRouter_StaticFS_Call) Return(iRoutes gin.IRoutes) *MockIRouter_StaticFS_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_StaticFS_Call) RunAndReturn(run func(s string, fileSystem http.FileSystem) gin.IRoutes) *MockIRouter_StaticFS_Call {
	_c.Call.Return(run)
	return _c
}

// StaticFile provides a mock function for the type MockIRouter
func (_mock *MockIRouter) StaticFile(s string, s1 string) gin.IRoutes {
	ret := _mock.Called(s, s1)

	if len(ret) == 0 {
		panic("no return value specified for StaticFile")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, string) gin.IRoutes); ok {
		r0 = returnFunc(s, s1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_StaticFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StaticFile'
type MockIRouter_StaticFile_Call struct {
	*mock.Call
}

// StaticFile is a helper method to define mock.On call
//   - s string
//   - s1 string
func (_e *MockIRouter_Expecter) StaticFile(s interface{}, s1 interface{}) *MockIRouter_StaticFile_Call {
	return &MockIRouter_StaticFile_Call{Call: _e.mock.On("StaticFile", s, s1)}
}

func (_c *MockIRouter_StaticFile_Call) Run(run func(s string, s1 string)) *MockIRouter_StaticFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRouter_StaticFile_Call) Return(iRoutes gin.IRoutes) *MockIRouter_StaticFile_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_StaticFile_Call) RunAndReturn(run func(s string, s1 string) gin.IRoutes) *MockIRouter_StaticFile_Call {
	_c.Call.Return(run)
	return _c
}

// StaticFileFS provides a mock function for the type MockIRouter
func (_mock *MockIRouter) StaticFileFS(s string, s1 string, fileSystem http.FileSystem) gin.IRoutes {
	ret := _mock.Called(s, s1, fileSystem)

	if len(ret) == 0 {
		panic("no return value specified for StaticFileFS")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, string, http.FileSystem) gin.IRoutes); ok {
		r0 = returnFunc(s, s1, fileSystem)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_StaticFileFS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StaticFileFS'
type MockIRouter_StaticFileFS_Call struct {
	*mock.Call
}

// StaticFileFS is a helper method to define mock.On call
//   - s string
//   - s1 string
//   - fileSystem http.FileSystem
func (_e *MockIRouter_Expecter) StaticFileFS(s interface{}, s1 interface{}, fileSystem interface{}) *MockIRouter_StaticFileFS_Call {
	return &MockIRouter_StaticFileFS_Call{Call: _e.mock.On("StaticFileFS", s, s1, fileSystem)}
}

func (_c *MockIRouter_StaticFileFS_Call) Run(run func(s string, s1 string, fileSystem http.FileSystem)) *MockIRouter_StaticFileFS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 http.FileSystem
		if args[2] != nil {
			arg2 = args[2].(http.FileSystem)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIRouter_StaticFileFS_Call) Return(iRoutes gin.IRoutes) *MockIRouter_StaticFileFS_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_StaticFileFS_Call) RunAndReturn(run func(s string, s1 string, fileSystem http.FileSystem) gin.IRoutes) *MockIRouter_StaticFileFS_Call {
	_c.Call.Return(run)
	return _c
}

// Use provides a mock function for the type MockIRouter
func (_mock *MockIRouter) Use(handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(handlerFuncs)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Use")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRouter_Use_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Use'
type MockIRouter_Use_Call struct {
	*mock.Call
}

// Use is a helper method to define mock.On call
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRouter_Expecter) Use(handlerFuncs ...interface{}) *MockIRouter_Use_Call {
	return &MockIRouter_Use_Call{Call: _e.mock.On("Use",
		append([]interface{}{}, handlerFuncs...)...)}
}

func (_c *MockIRouter_Use_Call) Run(run func(handlerFuncs ...gin.HandlerFunc)) *MockIRouter_Use_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 0 {
			variadicArgs = args[0].([]gin.HandlerFunc)
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *MockIRouter_Use_Call) Return(iRoutes gin.IRoutes) *MockIRouter_Use_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRouter_Use_Call) RunAndReturn(run func(handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRouter_Use_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIRoutes creates a new instance of MockIRoutes. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIRoutes(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIRoutes {
	mock := &MockIRoutes{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIRoutes is an autogenerated mock type for the IRoutes type
type MockIRoutes struct {
	mock.Mock
}

type MockIRoutes_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIRoutes) EXPECT() *MockIRoutes_Expecter {
	return &MockIRoutes_Expecter{mock: &_m.Mock}
}

// Any provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) Any(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Any")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_Any_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Any'
type MockIRoutes_Any_Call struct {
	*mock.Call
}

// Any is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) Any(s interface{}, handlerFuncs ...interface{}) *MockIRoutes_Any_Call {
	return &MockIRoutes_Any_Call{Call: _e.mock.On("Any",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_Any_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_Any_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRoutes_Any_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_Any_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_Any_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_Any_Call {
	_c.Call.Return(run)
	return _c
}

// DELETE provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) DELETE(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DELETE")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_DELETE_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DELETE'
type MockIRoutes_DELETE_Call struct {
	*mock.Call
}

// DELETE is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) DELETE(s interface{}, handlerFuncs ...interface{}) *MockIRoutes_DELETE_Call {
	return &MockIRoutes_DELETE_Call{Call: _e.mock.On("DELETE",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_DELETE_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_DELETE_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRoutes_DELETE_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_DELETE_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_DELETE_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_DELETE_Call {
	_c.Call.Return(run)
	return _c
}

// GET provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) GET(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GET")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_GET_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GET'
type MockIRoutes_GET_Call struct {
	*mock.Call
}

// GET is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) GET(s interface{}, handlerFuncs ...interface{}) *MockIRoutes_GET_Call {
	return &MockIRoutes_GET_Call{Call: _e.mock.On("GET",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_GET_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_GET_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRoutes_GET_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_GET_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_GET_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_GET_Call {
	_c.Call.Return(run)
	return _c
}

// HEAD provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) HEAD(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HEAD")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_HEAD_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HEAD'
type MockIRoutes_HEAD_Call struct {
	*mock.Call
}

// HEAD is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) HEAD(s interface{}, handlerFuncs ...interface{}) *MockIRoutes_HEAD_Call {
	return &MockIRoutes_HEAD_Call{Call: _e.mock.On("HEAD",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_HEAD_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_HEAD_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRoutes_HEAD_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_HEAD_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_HEAD_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_HEAD_Call {
	_c.Call.Return(run)
	return _c
}

// Handle provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) Handle(s string, s1 string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, s1, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s, s1)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Handle")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, s1, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockIRoutes_Handle_Call struct {
	*mock.Call
}

// Handle is a helper method to define mock.On call
//   - s string
//   - s1 string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) Handle(s interface{}, s1 interface{}, handlerFuncs ...interface{}) *MockIRoutes_Handle_Call {
	return &MockIRoutes_Handle_Call{Call: _e.mock.On("Handle",
		append([]interface{}{s, s1}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_Handle_Call) Run(run func(s string, s1 string, handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_Handle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 2 {
			variadicArgs = args[2].([]gin.HandlerFunc)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockIRoutes_Handle_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_Handle_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_Handle_Call) RunAndReturn(run func(s string, s1 string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_Handle_Call {
	_c.Call.Return(run)
	return _c
}

// OPTIONS provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) OPTIONS(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for OPTIONS")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_OPTIONS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OPTIONS'
type MockIRoutes_OPTIONS_Call struct {
	*mock.Call
}

// OPTIONS is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) OPTIONS(s interface{}, handlerFuncs ...interface{}) *MockIRoutes_OPTIONS_Call {
	return &MockIRoutes_OPTIONS_Call{Call: _e.mock.On("OPTIONS",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_OPTIONS_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_OPTIONS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRoutes_OPTIONS_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_OPTIONS_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_OPTIONS_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_OPTIONS_Call {
	_c.Call.Return(run)
	return _c
}

// PATCH provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) PATCH(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PATCH")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_PATCH_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PATCH'
type MockIRoutes_PATCH_Call struct {
	*mock.Call
}

// PATCH is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) PATCH(s interface{}, handlerFuncs ...interface{}) *MockIRoutes_PATCH_Call {
	return &MockIRoutes_PATCH_Call{Call: _e.mock.On("PATCH",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_PATCH_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_PATCH_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRoutes_PATCH_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_PATCH_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_PATCH_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_PATCH_Call {
	_c.Call.Return(run)
	return _c
}

// POST provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) POST(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for POST")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_POST_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'POST'
type MockIRoutes_POST_Call struct {
	*mock.Call
}

// POST is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) POST(s interface{}, handlerFuncs ...interface{}) *MockIRoutes_POST_Call {
	return &MockIRoutes_POST_Call{Call: _e.mock.On("POST",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_POST_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_POST_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRoutes_POST_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_POST_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_POST_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_POST_Call {
	_c.Call.Return(run)
	return _c
}

// PUT provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) PUT(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(s, handlerFuncs)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PUT")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, ...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(s, handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_PUT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PUT'
type MockIRoutes_PUT_Call struct {
	*mock.Call
}

// PUT is a helper method to define mock.On call
//   - s string
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) PUT(s interface{}, handlerFuncs ...interface{}) *MockIRoutes_PUT_Call {
	return &MockIRoutes_PUT_Call{Call: _e.mock.On("PUT",
		append([]interface{}{s}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_PUT_Call) Run(run func(s string, handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_PUT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 1 {
			variadicArgs = args[1].([]gin.HandlerFunc)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockIRoutes_PUT_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_PUT_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_PUT_Call) RunAndReturn(run func(s string, handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_PUT_Call {
	_c.Call.Return(run)
	return _c
}

// Static provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) Static(s string, s1 string) gin.IRoutes {
	ret := _mock.Called(s, s1)

	if len(ret) == 0 {
		panic("no return value specified for Static")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, string) gin.IRoutes); ok {
		r0 = returnFunc(s, s1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_Static_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Static'
type MockIRoutes_Static_Call struct {
	*mock.Call
}

// Static is a helper method to define mock.On call
//   - s string
//   - s1 string
func (_e *MockIRoutes_Expecter) Static(s interface{}, s1 interface{}) *MockIRoutes_Static_Call {
	return &MockIRoutes_Static_Call{Call: _e.mock.On("Static", s, s1)}
}

func (_c *MockIRoutes_Static_Call) Run(run func(s string, s1 string)) *MockIRoutes_Static_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRoutes_Static_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_Static_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_Static_Call) RunAndReturn(run func(s string, s1 string) gin.IRoutes) *MockIRoutes_Static_Call {
	_c.Call.Return(run)
	return _c
}

// StaticFS provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) StaticFS(s string, fileSystem http.FileSystem) gin.IRoutes {
	ret := _mock.Called(s, fileSystem)

	if len(ret) == 0 {
		panic("no return value specified for StaticFS")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, http.FileSystem) gin.IRoutes); ok {
		r0 = returnFunc(s, fileSystem)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_StaticFS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StaticFS'
type MockIRoutes_StaticFS_Call struct {
	*mock.Call
}

// StaticFS is a helper method to define mock.On call
//   - s string
//   - fileSystem http.FileSystem
func (_e *MockIRoutes_Expecter) StaticFS(s interface{}, fileSystem interface{}) *MockIRoutes_StaticFS_Call {
	return &MockIRoutes_StaticFS_Call{Call: _e.mock.On("StaticFS", s, fileSystem)}
}

func (_c *MockIRoutes_StaticFS_Call) Run(run func(s string, fileSystem http.FileSystem)) *MockIRoutes_StaticFS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 http.FileSystem
		if args[1] != nil {
			arg1 = args[1].(http.FileSystem)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRoutes_StaticFS_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_StaticFS_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_StaticFS_Call) RunAndReturn(run func(s string, fileSystem http.FileSystem) gin.IRoutes) *MockIRoutes_StaticFS_Call {
	_c.Call.Return(run)
	return _c
}

// StaticFile provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) StaticFile(s string, s1 string) gin.IRoutes {
	ret := _mock.Called(s, s1)

	if len(ret) == 0 {
		panic("no return value specified for StaticFile")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, string) gin.IRoutes); ok {
		r0 = returnFunc(s, s1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_StaticFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StaticFile'
type MockIRoutes_StaticFile_Call struct {
	*mock.Call
}

// StaticFile is a helper method to define mock.On call
//   - s string
//   - s1 string
func (_e *MockIRoutes_Expecter) StaticFile(s interface{}, s1 interface{}) *MockIRoutes_StaticFile_Call {
	return &MockIRoutes_StaticFile_Call{Call: _e.mock.On("StaticFile", s, s1)}
}

func (_c *MockIRoutes_StaticFile_Call) Run(run func(s string, s1 string)) *MockIRoutes_StaticFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRoutes_StaticFile_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_StaticFile_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_StaticFile_Call) RunAndReturn(run func(s string, s1 string) gin.IRoutes) *MockIRoutes_StaticFile_Call {
	_c.Call.Return(run)
	return _c
}

// StaticFileFS provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) StaticFileFS(s string, s1 string, fileSystem http.FileSystem) gin.IRoutes {
	ret := _mock.Called(s, s1, fileSystem)

	if len(ret) == 0 {
		panic("no return value specified for StaticFileFS")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(string, string, http.FileSystem) gin.IRoutes); ok {
		r0 = returnFunc(s, s1, fileSystem)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_StaticFileFS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StaticFileFS'
type MockIRoutes_StaticFileFS_Call struct {
	*mock.Call
}

// StaticFileFS is a helper method to define mock.On call
//   - s string
//   - s1 string
//   - fileSystem http.FileSystem
func (_e *MockIRoutes_Expecter) StaticFileFS(s interface{}, s1 interface{}, fileSystem interface{}) *MockIRoutes_StaticFileFS_Call {
	return &MockIRoutes_StaticFileFS_Call{Call: _e.mock.On("StaticFileFS", s, s1, fileSystem)}
}

func (_c *MockIRoutes_StaticFileFS_Call) Run(run func(s string, s1 string, fileSystem http.FileSystem)) *MockIRoutes_StaticFileFS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 http.FileSystem
		if args[2] != nil {
			arg2 = args[2].(http.FileSystem)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIRoutes_StaticFileFS_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_StaticFileFS_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_StaticFileFS_Call) RunAndReturn(run func(s string, s1 string, fileSystem http.FileSystem) gin.IRoutes) *MockIRoutes_StaticFileFS_Call {
	_c.Call.Return(run)
	return _c
}

// Use provides a mock function for the type MockIRoutes
func (_mock *MockIRoutes) Use(handlerFuncs ...gin.HandlerFunc) gin.IRoutes {
	var tmpRet mock.Arguments
	if len(handlerFuncs) > 0 {
		tmpRet = _mock.Called(handlerFuncs)
	} else {
		tmpRet = _mock.Called()
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Use")
	}

	var r0 gin.IRoutes
	if returnFunc, ok := ret.Get(0).(func(...gin.HandlerFunc) gin.IRoutes); ok {
		r0 = returnFunc(handlerFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gin.IRoutes)
		}
	}
	return r0
}

// MockIRoutes_Use_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Use'
type MockIRoutes_Use_Call struct {
	*mock.Call
}

// Use is a helper method to define mock.On call
//   - handlerFuncs ...gin.HandlerFunc
func (_e *MockIRoutes_Expecter) Use(handlerFuncs ...interface{}) *MockIRoutes_Use_Call {
	return &MockIRoutes_Use_Call{Call: _e.mock.On("Use",
		append([]interface{}{}, handlerFuncs...)...)}
}

func (_c *MockIRoutes_Use_Call) Run(run func(handlerFuncs ...gin.HandlerFunc)) *MockIRoutes_Use_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []gin.HandlerFunc
		var variadicArgs []gin.HandlerFunc
		if len(args) > 0 {
			variadicArgs = args[0].([]gin.HandlerFunc)
		}
		arg0 = variadicArgs
		run(
			arg0...,
		)
	})
	return _c
}

func (_c *MockIRoutes_Use_Call) Return(iRoutes gin.IRoutes) *MockIRoutes_Use_Call {
	_c.Call.Return(iRoutes)
	return _c
}

func (_c *MockIRoutes_Use_Call) RunAndReturn(run func(handlerFuncs ...gin.HandlerFunc) gin.IRoutes) *MockIRoutes_Use_Call {
	_c.Call.Return(run)
	return _c
}
